
#include "stdafx.h"

#include <nx\winutil\path.h>
#include <nx\winutil\process.h>
#include <nx\crypt\sha.h>
#include <nx\common\time.h>

#include <nx\rmc\viewermgr.h>
#include <nx\rmc\repo.h>
#include <nx\rmc\session.h>


using namespace NX;
using namespace NX::rapidjson;


std::vector<DWORD> RmSession::GetActiveViewerProcesses()
{
	return _viewerMgr.GetJobProcesses();
}

std::wstring GenerateLocalUnprotectedTempFileName(const std::wstring& path, const std::wstring& extension)
{
	NX::time::datetime dt = NX::time::datetime::current_time();
	std::wstring data(path + L"/" + dt.serialize(false, true));
	UCHAR buf[32];
	memset(buf, 0, 32);
	NX::crypt::CreateSha256((const UCHAR*)data.c_str(), (ULONG)data.length() * 2, buf);
	return std::wstring(NX::bintohs<wchar_t>(buf, 32) + extension);
}

Result RmSession::ViewLocalFile(const std::wstring& path, const std::wstring& displayName, _In_opt_ bool* cancelFlag)
{
	Result res = RESULT(0);

	std::shared_ptr<NX::NXL::File> fp(LocalFileOpen(path, true, res));
	if (!res) {
		if (res.GetCode() == ERROR_ACCESS_DENIED) {//write activity log
			const std::wstring & filename = NX::get_file_name(path);
			(VOID)LogActivityView(false,
				NX::bintohs<wchar_t>(fp->GetFileSecret().GetToken().GetId().data(), fp->GetFileSecret().GetToken().GetId().size()),
				fp->GetFileSecret().GetOwnerIdW(),
				L"Local",
				L"", 
				filename,
				path);
		}
		return res;
	}

	LARGE_INTEGER liFileSize = { 0 };
	GetFileSizeEx(fp->GetFileHandle(), &liFileSize);
	FILETIME createTime = { 0 };
	FILETIME lastWriteTime = { 0 };
	GetFileTime(fp->GetFileHandle(), &createTime, NULL, &lastWriteTime);
	const NX::time::datetime dtLastWriteTime((0 != lastWriteTime.dwLowDateTime || 0 != lastWriteTime.dwHighDateTime) ? (&lastWriteTime) : (&createTime));

	if(!fp->IsFullToken())
		return RESULT(ERROR_NO_USER_SESSION_KEY);

	NXL::FileMeta metadata;
	res = fp->ReadMetadata(metadata);
	if (!res)
		return res;

	std::wstring& sExt = metadata.Get(L"fileExtension");

	std::shared_ptr<RmViewer> spViewer = _viewerMgr.GetLocalViewer(sExt);
	if (spViewer == NULL) {
		fp.reset();
		return RunRemoteViewer(path, displayName, cancelFlag);
	}

	// We need to decrypt the file first
	const std::wstring& tmpFileName = GenerateLocalUnprotectedTempFileName(path, sExt);
	const std::wstring tmpFilePath(GetCurrentUserTempDir() + L"\\" + tmpFileName);
	res = fp->Unprotect(tmpFilePath);
	if (!res)
		return res;

	RmLocalViewerData vdata;
	vdata._tempFilePath = tmpFilePath;			// The temp file generated by RMC which can be read by viewer
	vdata._filePath = displayName;				// Original file path (repository file path or on local/remote disk)
	vdata._fileId = displayName;				// Repository file id or file path(if file is on local/remote disk)
	vdata._fileUid = NX::bintohs<wchar_t>(fp->GetFileSecret().GetToken().GetId().data(), fp->GetFileSecret().GetToken().GetId().size());			// NXL File DUID
	vdata._originalFileName = metadata.Get(L"fileName");		// File's original name (No NXL extension)
	vdata._lastModifiedTime = dtLastWriteTime.to_java_time();		// File 's last modified time, milliseconds
	vdata._fileSize = liFileSize.QuadPart;				// File size
	vdata._offline = false;;				// Is it repository offline file
	vdata._favorite = false;				// Is it repository favorite file
	vdata._local = true;					// Is file on local/remote disk
	vdata._tempFileEncrypted = false;		// Is temp file encrypted

	// Close temp file
	fp.reset();

	res = spViewer->CreateInstance(&vdata, NULL, 0, NULL);
	if (!res) {
		::DeleteFileW(tmpFilePath.c_str());
	}
	return res;
}

std::wstring RmSession::RepoFileCreateCacheId(const NX::RmRepository& repo, const RmRepoFile& file)
{
	std::wstring s(repo.GetId() + file.GetId() + NX::i64tos<wchar_t>(file.GetLastModifiedTime()));
	NX::tolower<wchar_t>(s);
	UCHAR hash[20] = { 0 };
	Result res = NX::crypt::CreateSha1((const unsigned char*)s.c_str(), (ULONG)(s.length() * 2), hash);
	if (!res)
		return std::wstring();
	return NX::bintohs<wchar_t>(hash, 20);
}

Result RmSession::ViewRepoFile(NX::RmRepository& repo, const std::wstring& pathId, _In_opt_ bool* cancelFlag)
{
	RmRepoFile repoFile;
	Result res = RepoGetFileInfo(repo, pathId, repoFile);
	if (!res)
		return res;

	NX::RmRestStatus status;
	std::vector<std::wstring> viewerCookies;
	std::wstring viewerUrl;
	std::wstring fid = repoFile.GetId();
	if (repo.GetType() == RmRepository::ONEDRIVE) {
		size_t nfind = fid.find_last_of(L'/');
		if (std::wstring::npos != nfind) {
			fid = fid.substr(nfind + 1);
		}
	}
	res = _restClient.RemoteViewerForRepoFile(_rmserver.GetUrl(),
		cancelFlag,
		repo.GetId(),
		repo.GetName(),
		repo.GetTypeName(),
		fid,
		repoFile.GetPath(),
		GetCurrentUser().GetEmail(),
		repoFile.GetLastModifiedTime(),
		status,
		viewerCookies,
		viewerUrl);
	if (!res)
		return res;
	if (!status) {
		res = RESULT2(status.GetStatus(), NX::conv::utf16toutf8(status.GetPhrase()));
		return res;
	}

	const RmRemoteViewerData viewerData(viewerCookies, viewerUrl);
	if (cancelFlag && *cancelFlag)
		return RESULT(ERROR_CANCELLED);

	return CreateRemoteViewerProcessEx(NULL, viewerData);
}

Result RmSession::ViewProjectFile(const std::wstring& projectID, const std::wstring& pathId, _In_opt_ bool* cancelFlag)
{
	RmProjectFileMetadata projectFile;
	Result res = ProjectGetFileMetadata(projectID, pathId, projectFile);
	if (!res)
		return res;

	NX::RmRestStatus status;
	std::vector<std::wstring> viewerCookies;
	std::wstring viewerUrl;

	res = _restClient.RemoteViewerForProjectFile(_rmserver.GetUrl(),
		cancelFlag,
        projectID,
		projectFile.GetPath(),
		projectFile.GetDisplayPath(),
		GetCurrentUser().GetEmail(),
		projectFile.GetLastModifiedTime(),
		status,
		viewerCookies,
		viewerUrl);
	if (!res)
		return res;
	if (!status) {
		res = RESULT2(status.GetStatus(), NX::conv::utf16toutf8(status.GetPhrase()));
		return res;
	}

	const RmRemoteViewerData viewerData(viewerCookies, viewerUrl);
	if (cancelFlag && *cancelFlag)
		return RESULT(ERROR_CANCELLED);

	return CreateRemoteViewerProcessEx(NULL, viewerData);
}

static std::wstring MyVaultFileCreateCacheId(const std::wstring& pathId)
{
	std::wstring s(L"MyVault" + pathId);
	NX::tolower<wchar_t>(s);
	UCHAR hash[20] = { 0 };
	Result res = NX::crypt::CreateSha1((const unsigned char*)s.c_str(), (ULONG)(s.length() * 2), hash);
	if (!res)
		return std::wstring();
	return NX::bintohs<wchar_t>(hash, 20);
}

Result RmSession::ViewMyVaultFile(NX::RmRepository& mydrive, const std::wstring& pathId, _In_opt_ bool* cancelFlag)
{
	return ViewRepoFile(mydrive, pathId, cancelFlag);
}

Result RmSession::RunRemoteViewer(const std::wstring& path, const std::wstring& fileName, _In_opt_ bool* cancelFlag)
{
	HANDLE h = NULL;
	Result res = CreateRemoteViewerProcess(&h, path, fileName, cancelFlag);
	if (!res)
		return res;

	assert(NULL != h);
	_viewerMgr.AddViewerJob(h);
	CloseHandle(h);
	return RESULT(0);
}

Result RmSession::CreateRemoteViewerProcess(PHANDLE ph, const std::wstring& path, const std::wstring& fileName, _In_opt_ bool* cancelFlag)
{
	NX::RmRestStatus status;
	std::vector<std::wstring> viewerCookies;
	std::wstring viewerUrl;
	NX::win::FilePath pathObject(path);

	Result res = _restClient.RemoteViewerNew(_rmserver.GetUrl(), path, fileName.empty() ? pathObject.GetFileName() : fileName, status, viewerCookies, viewerUrl, cancelFlag);
	if (!res)
		return res;
	if (!status) {
		res = RESULT2(status.GetStatus(), NX::conv::utf16toutf8(status.GetPhrase()));
		return res;
	}

	const RmRemoteViewerData viewerData(viewerCookies, viewerUrl);
	return CreateRemoteViewerProcessEx(ph, viewerData);
}

Result RmSession::CreateRemoteViewerProcessEx(PHANDLE ph, const RmRemoteViewerData& viewerData)
{
	HANDLE h = NULL;
	Result res = RESULT(0);

	if (NULL != ph) {
		*ph = NULL;
	}

	do {

		const std::string& base64 = viewerData.ToBase64(_clientId.GetClientKey().data(), (ULONG)_clientId.GetClientKey().size());

		const std::vector<std::pair<std::wstring, std::wstring>> viewerEnvData({
			std::pair<std::wstring, std::wstring>(NXRM_ENV_TYPE_NAME, L"Remote"),
			std::pair<std::wstring, std::wstring>(NXRM_ENV_VARIABLE_NAME, std::wstring(base64.begin(), base64.end()))
		});

		NX::win::ProcessEnvironment env(viewerEnvData);
		const std::vector<wchar_t>& block = env.CreateBlock();
		if(block.empty()) {
			res = RESULT(GetLastError());
			break;
		}

		STARTUPINFOW sti = { 0 };
		PROCESS_INFORMATION pi = { 0 };
		memset(&sti, 0, sizeof(sti));
		sti.cb = (DWORD)sizeof(sti);
		memset(&pi, 0, sizeof(pi));

		std::wstring cmd(L"\"");
		cmd.append(GetDirs().GetAppBinDir());
		cmd.append(L"\\nxrviewer.exe\"");

		if (!::CreateProcessW(NULL, (LPWSTR)cmd.c_str(), NULL, NULL, TRUE, CREATE_UNICODE_ENVIRONMENT | CREATE_SUSPENDED, (LPVOID)block.data(), NULL, &sti, &pi)) {
			res = RESULT(GetLastError());
			break;
		}		

		h = pi.hProcess;
		ResumeThread(pi.hThread);
		CloseHandle(pi.hThread);

	} while (FALSE);
	if (!res) {
		if (NULL != h) {
			CloseHandle(h);
			h = NULL;
		}
		return res;
	}

	if (NULL != ph) {
		*ph = h;
		h = NULL;
	}
	else {
		if (NULL != h) {
			CloseHandle(h);
			h = NULL;
		}
	}
	return RESULT(0);
}