
#include "stdafx.h"

#include <nx\crypt\dh.h>

#include "provider.h"


using namespace NX;
using namespace NX::crypt;


static const UCHAR DH2048_X509_PUBLIC_KEY_TEMPLATE[814] = {
    0x30, 0x82, 0x03, 0x2A, 0x30, 0x82, 0x02, 0x1C, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D,
    0x01, 0x03, 0x01, 0x30, 0x82, 0x02, 0x0D, 0x02, 0x82, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x02, 0x82, 0x01, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x02, 0x02, 0x04, 0x00, 0x03, 0x82, 0x01, 0x06, 0x00, 0x02, 0x82, 0x01, 0x01, 0x00, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

static const ULONG DH2048_X509_PUBLIC_KEY_P_OFFSET = 0x1C;
static const ULONG DH2048_X509_PUBLIC_KEY_G_OFFSET = 0x120;
static const ULONG DH2048_X509_PUBLIC_KEY_Y_OFFSET = 0x22E;


DhKeyBlob::DhKeyBlob()
{
}

DhKeyBlob::DhKeyBlob(_In_ ULONG bitslength,
    _In_reads_bytes_(bitslength/8) const UCHAR* p,
    _In_reads_bytes_(bitslength / 8) const UCHAR* g,
    _In_reads_bytes_(bitslength / 8) const UCHAR* y,
    _In_reads_bytes_opt_(bitslength / 8) const UCHAR* x)
{
    const Result& res = SetKey(bitslength, p, g, y, x);
    if(!res) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
}

DhKeyBlob::DhKeyBlob(const DhKeyBlob& rhs) : _data(rhs._data)
{
}

DhKeyBlob::~DhKeyBlob()
{
}

Result DhKeyBlob::SetKey(_In_ ULONG bitslength,
    _In_reads_bytes_(bitslength / 8) const UCHAR* p,
    _In_reads_bytes_(bitslength / 8) const UCHAR* g,
    _In_reads_bytes_(bitslength / 8) const UCHAR* y,
    _In_reads_bytes_opt_(bitslength / 8) const UCHAR* x)
{
    if (bitslength != 1024 && bitslength != 2048) {
        return RESULT(ERROR_INVALID_PARAMETER);
    }

    Clear();

    const ULONG key_size = bitslength / 8;
    const ULONG blob_size = sizeof(BCRYPT_DH_KEY_BLOB) + (x ? 4 : 3) * key_size;
    _data.resize(blob_size, 0);
    ((BCRYPT_DH_KEY_BLOB*)_data.data())->dwMagic = x ? BCRYPT_DH_PRIVATE_MAGIC : BCRYPT_DH_PUBLIC_MAGIC;
    ((BCRYPT_DH_KEY_BLOB*)_data.data())->cbKey = key_size;
    PUCHAR pb = _data.data() + sizeof(BCRYPT_DH_KEY_BLOB);
    memcpy(pb, p, key_size);    pb += key_size;
    memcpy(pb, g, key_size);    pb += key_size;
    memcpy(pb, y, key_size);    pb += key_size;
    if (x) {
        memcpy(pb, x, key_size);
    }

    return RESULT(0);
}

DhKeyBlob& DhKeyBlob::operator = (const DhKeyBlob& rhs)
{
    if (this != &rhs) {
        _data = rhs._data;
    }
    return *this;
}

bool DhKeyBlob::HasPrivateKey() const
{
    return (!Empty() && (BCRYPT_DH_PRIVATE_MAGIC == GetBlobHeader()->dwMagic));
}

ULONG DhKeyBlob::GetKeyBitsLength() const
{
    return Empty() ? 0 : (GetBlobHeader()->cbKey * 8);
}

const UCHAR* DhKeyBlob::GetP() const
{
    return Empty() ? NULL : (_data.data() + sizeof(BCRYPT_DH_KEY_BLOB));
}

const UCHAR* DhKeyBlob::GetG() const
{
    return Empty() ? NULL : (_data.data() + sizeof(BCRYPT_DH_KEY_BLOB) + GetKeyBytesLength());
}

const UCHAR* DhKeyBlob::GetY() const
{
    return Empty() ? NULL : (_data.data() + sizeof(BCRYPT_DH_KEY_BLOB) + GetKeyBytesLength() * 2);
}

const UCHAR* DhKeyBlob::GetX() const
{
    return HasPrivateKey() ? (_data.data() + sizeof(BCRYPT_DH_KEY_BLOB) + GetKeyBytesLength() * 3) : NULL;
}

Result DhKeyBlob::CreateX509EncodedPublicKey(std::vector<UCHAR>& encoded_pubkey)
{
    if (Empty()) {
        return RESULT(ERROR_INVALID_DATA);
    }

    if (1024 == GetKeyBitsLength()) {
        return RESULT(ERROR_NOT_SUPPORTED);
    }
    else if (2048 == GetKeyBitsLength()) {
        const ULONG key_size = GetKeyBytesLength();
        encoded_pubkey.resize(sizeof(DH2048_X509_PUBLIC_KEY_TEMPLATE), 0);
        memcpy(encoded_pubkey.data(), DH2048_X509_PUBLIC_KEY_TEMPLATE, sizeof(DH2048_X509_PUBLIC_KEY_TEMPLATE));
        memcpy(encoded_pubkey.data() + DH2048_X509_PUBLIC_KEY_P_OFFSET, GetP(), key_size);
        memcpy(encoded_pubkey.data() + DH2048_X509_PUBLIC_KEY_G_OFFSET, GetG(), key_size);
        memcpy(encoded_pubkey.data() + DH2048_X509_PUBLIC_KEY_Y_OFFSET, GetY(), key_size);
        return RESULT(0);
    }
    else {
        return RESULT(ERROR_INVALID_DATA);
    }
}

Result DhKeyBlob::ImportX509EncodedPublicKey(const UCHAR* encoded_pubkey, ULONG size)
{
    Clear();
    if (size == sizeof(DH2048_X509_PUBLIC_KEY_TEMPLATE)) {
        const ULONG bitslen = 2048;
        const UCHAR* p = encoded_pubkey + DH2048_X509_PUBLIC_KEY_P_OFFSET;
        const UCHAR* g = encoded_pubkey + DH2048_X509_PUBLIC_KEY_G_OFFSET;
        const UCHAR* y = encoded_pubkey + DH2048_X509_PUBLIC_KEY_Y_OFFSET;
        return SetKey(bitslen, p, g, y, NULL);
    }
    else {
        return RESULT(ERROR_INVALID_DATA);
    }
}


//
//  class DiffieHellmanKey
//
DiffieHellmanKey::DiffieHellmanKey() : Key(), _full_key(false)
{
}

DiffieHellmanKey::DiffieHellmanKey(const DhKeyBlob& blob) : Key(), _full_key(false)
{
    if (!blob.Empty()) {
        const Result& res = Import(blob._data.data(), (ULONG)blob._data.size());
        if (!res)
            SetLastError(res.GetCode());
    }
}

DiffieHellmanKey::~DiffieHellmanKey()
{
}

Result DiffieHellmanKey::Generate(ULONG bitslength)
{
    return RESULT(ERROR_NOT_SUPPORTED);
}

Result DiffieHellmanKey::Generate(_In_reads_bytes_(bitslength / 8) const UCHAR* p, _In_reads_bytes_(bitslength / 8)const UCHAR* g, ULONG bitslength)
{
    if (bitslength != 1024 && bitslength != 2048) {
        return RESULT(ERROR_INVALID_PARAMETER);
    }

    Provider* prov = GetProvider(PROV_DH);
    if (NULL == prov) {
        return RESULT(ERROR_INVALID_HANDLE);
    }
    if (!prov->Opened()) {
        return RESULT(ERROR_INVALID_HANDLE);
    }

    LONG status = 0;
    Result res = RESULT(0);

    do {

        status = BCryptGenerateKeyPair(*prov, &_h, bitslength, 0);
        if (0 != status) {
            res = RESULT2(status, "BCryptGenerateKeyPair failed");
            break;
        }

        const ULONG dh_size = sizeof(BCRYPT_DH_PARAMETER_HEADER) + (bitslength / 8) + (bitslength / 8);
        BCRYPT_DH_PARAMETER_HEADER* dh_parameter = NULL;
        std::vector<unsigned char> buf;
        buf.resize(dh_size, 0);
        dh_parameter = (BCRYPT_DH_PARAMETER_HEADER *)buf.data();
        dh_parameter->dwMagic = BCRYPT_DH_PARAMETERS_MAGIC;
        dh_parameter->cbLength = dh_size;
        dh_parameter->cbKeyLength = bitslength / 8;
        memcpy(buf.data() + sizeof(BCRYPT_DH_PARAMETER_HEADER), p, dh_parameter->cbKeyLength);
        memcpy(buf.data() + sizeof(BCRYPT_DH_PARAMETER_HEADER) + dh_parameter->cbKeyLength, g, dh_parameter->cbKeyLength);
        status = BCryptSetProperty(_h, BCRYPT_DH_PARAMETERS, buf.data(), dh_size, 0);
        if (0 != status) {
            res = RESULT2(status, "BCryptSetProperty (BCRYPT_DH_PARAMETERS) failed");
            break;
        }

        status = BCryptFinalizeKeyPair(_h, 0);
        if (0 != status) {
            res = RESULT2(status, "BCryptFinalizeKeyPair failed");
            break;
        }

        _bitslen = bitslength;

    } while (FALSE);

    if (!res) {
        if (_h) {
            BCryptDestroyKey(_h);
            _h = NULL;
        }
    }

    return res;
}

Result DiffieHellmanKey::Import(const UCHAR* key, ULONG size)
{
    Provider* prov = GetProvider(PROV_DH);
    if (NULL == prov) {
        return RESULT(ERROR_INVALID_HANDLE);
    }
    if (!prov->Opened()) {
        return RESULT(ERROR_INVALID_HANDLE);
    }

    LONG status = 0;
    const BCRYPT_DH_KEY_BLOB* header = (const BCRYPT_DH_KEY_BLOB*)key;

    if (BCRYPT_DH_PUBLIC_MAGIC == header->dwMagic) {

        status = BCryptImportKeyPair(*prov,
                                     NULL,
                                     BCRYPT_DH_PUBLIC_BLOB,
                                     &_h,
                                     (PUCHAR)key, (ULONG)size,
                                     0);
        if (0 != status) {
            return RESULT2(status, "BCryptImportKeyPair (public key) failed");
        }

        _full_key = false;
        QueryBitsLength();
        return RESULT(0);
    }
    else if (BCRYPT_DH_PRIVATE_MAGIC == header->dwMagic) {

        status = BCryptImportKeyPair(*prov,
                                     NULL,
                                     BCRYPT_DH_PRIVATE_BLOB,
                                     &_h,
                                     (PUCHAR)key, (ULONG)size,
                                     0);
        if (0 != status) {
            return RESULT2(status, "BCryptImportKeyPair (private key) failed");
        }

        _full_key = true;
        QueryBitsLength();
        return RESULT(0);
    }
    else {
        return RESULT(ERROR_INVALID_DATA);
    }
}

Result DiffieHellmanKey::Export(PUCHAR key, _Inout_ PULONG size)
{
    Provider* prov = GetProvider(PROV_DH);
    if (NULL == prov) {
        return RESULT(ERROR_INVALID_HANDLE);
    }
    if (!prov->Opened()) {
        return RESULT(ERROR_INVALID_HANDLE);
    }

    LONG status = 0;
    const ULONG outbuf_size = *size;

    status = BCryptExportKey(_h, NULL, HasPrivateKey() ? BCRYPT_DH_PRIVATE_BLOB : BCRYPT_DH_PUBLIC_BLOB, key, outbuf_size, size, 0);
    if (NULL == key || outbuf_size == 0) {
        // Query size only
        return RESULT((0 == *size) ? status : 0);
    }

    return RESULT(status);
}

Result DiffieHellmanKey::Export(DhKeyBlob& blob)
{
	ULONG requiredSize = 0;
	Result res = Export(NULL, &requiredSize);
	if (!res)
		return res;
	
	blob._data.resize(requiredSize, 0);
	return Export(blob._data.data(), &requiredSize);
}
