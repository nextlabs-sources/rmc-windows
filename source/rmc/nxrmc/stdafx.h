
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // Exclude rarely-used stuff from Windows headers
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // some CString constructors will be explicit

// turns off MFC's hiding of some common and often safely ignored warning messages
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions


#include <afxdisp.h>        // MFC Automation classes


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif


#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC support for Internet Explorer 4 Common Controls
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // MFC support for ribbons and control bars
#include <afx.h>
#include <afxdlgs.h>
#include "FlatDlgBase.h"




#ifdef _CRTDBG_MAP_ALLOC
#include <stdlib.h>  
#include <crtdbg.h>  
#endif // _CRTDBG_MAP_ALLOC





#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif


//Remove following veriable to remove release logging.
#define _RTRACE
//#ifdef PTCHAR
//#define PTCHAR wchar_t *
//#endif
//------------------------------------------------------------------------------------------------
//
// Based On: MSDN examples for variable argument lists and ATL implementation of TRACE.
//
// Description: Allows the use of TRACE statements in RELEASE builds, by overriding the
// TRACE macro definition and redefining in terms of the RTRACE class and overloaded
// operator (). Trace output is generated by calling OutputDebugString() directly.
//
//
// Usage:    Add to the end of stdafx.h and add _RTRACE to the preprocessor defines (typically
//           for RELEASE builds, although the flag will be ignored for DEBUG builds.
//
//------------------------------------------------------------------------------------------------

#ifdef _DEBUG

// NL defined as a shortcut for writing FTRACE(_T("\n")); for example, instead write FTRACE(NL);
#define NL _T("\n") 
#define LTRACE TRACE(_T("%s(%d): "), __FILE__, __LINE__); TRACE
#define FTRACE TRACE(_T("%s(%d): %s: "), __FILE__, __LINE__, __FUNCTION__); TRACE

#else   // _DEBUG

#ifdef _RTRACE
#undef TRACE
#define TRACE  RTRACE()
#define LTRACE RTRACE(__FILE__, __LINE__)
#define FTRACE RTRACE(__FILE__, __LINE__, __FUNCTION__)
#define NL _T("\n") 

class RTRACE
{
public:
	// default constructor, no params
	RTRACE(void) : m_pszFileName(NULL), m_nLineNo(0), m_pszFuncName(NULL) {};

	// overloaded constructor, filename and lineno
	RTRACE(PCTSTR const pszFileName, int nLineNo) :
		m_pszFileName(pszFileName), m_nLineNo(nLineNo), m_pszFuncName(NULL) {};

	// overloaded constructor, filename, lineno, and function name
	RTRACE(PCTSTR const pszFileName, int nLineNo, PCTSTR const pszFuncName) :
		m_pszFileName(pszFileName), m_nLineNo(nLineNo), m_pszFuncName(pszFuncName) {};

	virtual ~RTRACE(void) {};

	// no arguments passed, e.g. RTRACE()()
	void operator()() const
	{
		// no arguments passed, just dump the file, line and function if requested
		OutputFileAndLine();
		OutputFunction();
	}

	// format string and parameters passed, e.g. RTRACE()(_T("%s\n"), someStringVar)
	//void operator()(const PTCHAR pszFmt, ...) const
	void operator()(const wchar_t *pszFmt, ...) const
	{
		// dump the file, line and function if requested, followed by the TRACE arguments
		OutputFileAndLine();
		OutputFunction();

		// perform the standard TRACE output processing
		va_list ptr; va_start(ptr, pszFmt);
		INT len = _vsctprintf(pszFmt, ptr) + 1;
		TCHAR* buffer = (PTCHAR)malloc(len * sizeof(TCHAR));
		_vstprintf_s(buffer,len, pszFmt, ptr);
		OutputDebugString(buffer);
		free(buffer);
	}

private:
	// output the current file and line
	inline void OutputFileAndLine() const
	{
		if (m_pszFileName && _tcslen(m_pszFileName) > 0)
		{
			INT len = _sctprintf(_T("%s(%d): "), m_pszFileName, m_nLineNo) + 1;
			PTCHAR buffer = (PTCHAR)malloc(len * sizeof(TCHAR));
			_stprintf_s(buffer,len, _T("%s(%d): "), m_pszFileName, m_nLineNo);
			OutputDebugString(buffer);
			free(buffer);
		}
	}

	// output the current function name
	inline void OutputFunction() const
	{
		if (m_pszFuncName && _tcslen(m_pszFuncName) > 0)
		{
			INT len = _sctprintf(_T("%s: "), m_pszFuncName) + 1;
			PTCHAR buffer = (PTCHAR)malloc(len * sizeof(TCHAR));
			_stprintf_s(buffer, len, _T("%s: "), m_pszFuncName);
			OutputDebugString(buffer);
			free(buffer);
		}
	}

private:
	PCTSTR const m_pszFuncName;
	PCTSTR const m_pszFileName;
	const int m_nLineNo;
};

#endif // _RTRACE

#endif // NDEBUG
