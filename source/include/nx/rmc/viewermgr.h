

#ifndef __LIBRMC_VIEWERMGR_H__
#define __LIBRMC_VIEWERMGR_H__

#include <nx\rmc\dirs.h>
#include <nx\rmc\tenant.h>
#include <nx\rmc\user.h>
#include <nx\rmc\rest.h>

#include <nx\nxl\nxlfile.h>

#include <nx\common\result.h>

#include <string>
#include <unordered_map>

#define NXRM_ENV_TYPE_NAME		L"X_NXRM_VIEWER_TYPE"
#define NXRM_ENV_VARIABLE_NAME	L"X_NXRM_VIEWER_PARAMS"

namespace NX {

	class RmViewerData
	{
	public:
		typedef enum VIEWERTYPE {
			RemoteViewer = 0,
			LocalViewer
		} VIEWERTYPE;

		RmViewerData() : _viewerType(RemoteViewer) {}
		RmViewerData(VIEWERTYPE vtype) : _viewerType(vtype) {}
		virtual ~RmViewerData() {}

		inline VIEWERTYPE GetViewerType() const { return _viewerType; }
		inline bool IsRemoteViewer() const { return (RemoteViewer == _viewerType); }

		std::string ToBase64(const UCHAR* key, ULONG size) const;
		Result FromBase64(const std::string& sbase64, const UCHAR* key, ULONG size);

	protected:
		virtual std::string serialize() const = 0;
		virtual Result deserialize(const std::string& s) = 0;

	protected:
		VIEWERTYPE	_viewerType;

	private:
		// Copy is not allowed
		RmViewerData(const RmViewerData& rhs) {};
		RmViewerData(RmViewerData&& rhs) {};
	};

	class RmRemoteViewerData : public RmViewerData
	{
	public:
		RmRemoteViewerData();
		RmRemoteViewerData(const std::vector<std::wstring>& cookies, const std::wstring& url);
		virtual ~RmRemoteViewerData();

		inline const std::vector<std::wstring>& GetCookies() const { return _viewerCookies; }
		inline const std::wstring& GetUrl() const { return _viewerUrl; }

	protected:
		virtual std::string serialize() const;
		virtual Result deserialize(const std::string& s);

	private:
		// Copy is not allowed
		RmRemoteViewerData(const RmRemoteViewerData& rhs) {};
		RmRemoteViewerData(RmRemoteViewerData&& rhs) {};

	private:
		std::vector<std::wstring>	_viewerCookies;
		std::wstring	_viewerUrl;
	};

	class RmLocalViewerData : public RmViewerData
	{
	public:
		RmLocalViewerData();
		virtual ~RmLocalViewerData();

		inline const std::wstring& GetTmpFilePath() const { return _tempFilePath; }
		inline const std::wstring& GetFilePath() const { return _filePath; }
		inline const std::wstring& GetFileId() const { return _fileId; }
		inline const std::wstring& GetFileDuid() const { return _fileUid; }
		inline const std::wstring& GetOriginalFileName() const { return _originalFileName; }
		inline __int64 GetFileSize() const { return _fileSize; }
		inline __int64 GetLastModifiedTime() const { return _lastModifiedTime; }
		inline bool IsOfflineFile() const { return _offline; }
		inline bool IsFavoriteFile() const { return _favorite; }
		inline bool IsLocalFile() const { return _local; }

	protected:
		virtual std::string serialize() const;
		virtual Result deserialize(const std::string& s);

	private:
		// Copy is not allowed
		RmLocalViewerData(const RmLocalViewerData& rhs) {};
		RmLocalViewerData(RmLocalViewerData&& rhs) {};

	private:
		std::wstring	_tempFilePath;			// The temp file generated by RMC which can be read by viewer
		std::wstring	_filePath;				// Original file path (repository file path or on local/remote disk)
		std::wstring	_fileId;				// Repository file id or file path(if file is on local/remote disk)
		std::wstring	_fileUid;				// NXL File DUID
		std::wstring	_originalFileName;		// File's original name (No NXL extension)
		__int64			_lastModifiedTime;		// File 's last modified time, milliseconds
		__int64			_fileSize;				// File size
		bool			_offline;				// Is it repository offline file
		bool			_favorite;				// Is it repository favorite file
		bool			_local;					// Is file on local/remote disk
		bool			_tempFileEncrypted;		// Is temp file encrypted

		friend class RmSession;
	};

	class RmSupportFileType
	{
	public:
		RmSupportFileType();
		RmSupportFileType(const RmSupportFileType& rhs);
		RmSupportFileType(const std::wstring& type, const std::wstring& descritpion,  int metric);
		RmSupportFileType& operator = (const RmSupportFileType& rhs);

		void clear();

		inline bool empty() const { return _type.empty(); }
		inline const std::wstring& GetType() const { return _type; }
		inline const std::wstring& GetDescritpion() const { return _descritpion; }
		inline int GetMetric() const { return _metric; }

	private:
		std::wstring	_type;
		std::wstring	_descritpion;
		int	_metric;
	};

	class RmViewer
	{
	public:
		virtual ~RmViewer();

		static RmViewer* Load(const std::wstring& dir);

		Result CreateInstance(const RmViewerData* data, const UCHAR* key, ULONG keySize, _Out_opt_ PHANDLE ph);
		virtual bool IsRemoteViewer() const { return false; }

		inline bool IsExecutable() const { return (0 == _wcsicmp(_type.c_str(), L"Executable")); }
		inline const std::wstring& GetName() const { return _name; }
		inline const std::wstring& GetType() const { return _type; }
		inline const std::wstring& GetVersion() const { return _version; }
		inline const std::wstring& GetInterfaceVersion() const { return _interface; }
		inline const std::wstring& GetPath() const { return _path; }
		inline const std::unordered_map<std::wstring, RmSupportFileType>& GetSupportTypes() const { return _supportTypes; }

	protected:
		RmViewer();
		RmViewer(const std::wstring& name,
				 const std::wstring& type,
				 const std::wstring& version,
				 const std::wstring& interfaceVer,
				 const std::wstring& path);

	private:
		std::wstring	_name;
		std::wstring	_type;
		std::wstring	_version;
		std::wstring	_interface;
		std::wstring	_path;
		std::unordered_map<std::wstring, RmSupportFileType> _supportTypes;
	};


	class RmRemoteViewer : public RmViewer
	{
	public:
		RmRemoteViewer(const std::wstring& path) : RmViewer(L"SkyDRM Remote Viewer", L"Executable", L"1.0.0", L"1.0", path) {}
		virtual ~RmRemoteViewer() {}
		virtual bool IsRemoteViewer() const { return true; }
	};

	class RmViewerManager
	{
	public:
		RmViewerManager();
		~RmViewerManager();

		Result Init(const std::wstring& binDir);
		void Cleanup();

		Result AddViewerJob(HANDLE hProcess);
		std::vector<DWORD> GetJobProcesses();

		inline const std::vector<std::shared_ptr<RmViewer>>& GetViewers() const { return _viewers; }
		inline std::shared_ptr<RmViewer> GetRemoteViewer() const { return _remoteViewer; }
		std::shared_ptr<RmViewer> GetLocalViewer(const std::wstring& fileOrExtension) const;


	protected:
		void LoadViewers(const std::wstring& viewersDir);
		void ClearViewers();

	private:
		HANDLE	_h;	// Job Object handle
		std::wstring _binDir;
		std::shared_ptr<RmRemoteViewer>	_remoteViewer;
		std::vector<std::shared_ptr<RmViewer>> _viewers;
		std::unordered_map<std::wstring, std::pair<int,std::shared_ptr<RmViewer>>> _fileTypeToViewer;
	};
}


#endif